//
// main.cpp
// Main file
// ----------------------------------
// Developed with embedXcode
// http://embedXcode.weebly.com
//
// Project 		SPEEEduino_LowLevel
//
// Created by 	Pan Ziyue, 8/7/17 9:42 PM
//              MakerFoundry
//
// Copyright 	Â© Pan Ziyue, 2017
// Licence 		<#licence#>
//
// See 			SPEEEduino_LowLevel.ino and ReadMe.txt for references
//
// ----------------------------------
// DO NOT EDIT THIS FILE.
// THE SKETCH IS IN SPEEEduino_LowLevel.ino
// ----------------------------------
//
// Last update: Jan 18, 2017 release 6.0.9

// IDE selection
#if defined(EMBEDXCODE)

// Core library and main()
#if defined(REDBEARLAB_DUO)
#warning MAIN_SECTION 37 = RedBear Duo
// ============================================================================= RedBear Duo specific

#elif defined(SIMBLEE)
#warning MAIN_SECTION 39 = Simblee
// ============================================================================= Digistump Oak

#elif defined(OAK)
#warning MAIN_SECTION 36 = Digistump Oak
// ============================================================================= Digistump Oak

#elif defined(UDOO_NEO_M4) || defined(UDOO_NEO)
#warning MAIN_SECTION 35 = UDOO Neo M4
// ============================================================================= UDOO Neo M4 specific


#elif defined(__LINKIT_ONE__)
#warning MAIN_SECTION 1 = LINKIT_ONE
// ============================================================================= LinkIt One specific


#elif defined(__LINKIT_DUO__)
#warning MAIN_SECTION 38 = LINKIT_DUO
// ============================================================================= LinkIt Smart 7688 Duo specific


#elif defined(ESP8266)
#warning MAIN_SECTION 2 = ESP8266
// ============================================================================= ESP8266 specific

// from core_esp8266_main.cpp

/*  RELEASE 2.3.0 only
*/
/*
    main.cpp - platform initialization and context switching
    emulation

    Copyright (c) 2014 Ivan Grokhotkov. All rights reserved.
    This file is part of the esp8266 core for Arduino environment.

    This library is free software; you can redistribute it and/or
    modify it under the terms of the GNU Lesser General Public
    License as published by the Free Software Foundation; either
    version 2.1 of the License, or (at your option) any later version.

    This library is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
    Lesser General Public License for more details.

    You should have received a copy of the GNU Lesser General Public
    License along with this library; if not, write to the Free Software
    Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
*/

//This may be used to change user task stack size:
//#define CONT_STACKSIZE 4096
#include <Arduino.h>
#include "Schedule.h"
extern "C" {
#include "ets_sys.h"
#include "os_type.h"
#include "osapi.h"
#include "mem.h"
#include "user_interface.h"
#include "cont.h"
}
#include <core_version.h>

#define LOOP_TASK_PRIORITY 1
#define LOOP_QUEUE_SIZE    1

#define OPTIMISTIC_YIELD_TIME_US 16000

struct rst_info resetInfo;

extern "C" {
    extern const uint32_t __attribute__((section(".ver_number"))) core_version = ARDUINO_ESP8266_GIT_VER;
    const char* core_release =
#ifdef ARDUINO_ESP8266_RELEASE
    ARDUINO_ESP8266_RELEASE;
#else
    NULL;
#endif
} // extern "C"

int atexit(void (*func)())
{
    return 0;
}

extern "C" void ets_update_cpu_frequency(int freqmhz);
void initVariant() __attribute__((weak));
void initVariant()
{
}

extern void loop();
extern void setup();

void preloop_update_frequency() __attribute__((weak));
void preloop_update_frequency()
{
#if defined(F_CPU) && (F_CPU == 160000000L)
    REG_SET_BIT(0x3ff00014, BIT(0));
    ets_update_cpu_frequency(160);
#endif
}

extern void (*__init_array_start)(void);
extern void (*__init_array_end)(void);

cont_t g_cont __attribute__((aligned(16)));
static os_event_t g_loop_queue[LOOP_QUEUE_SIZE];

static uint32_t g_micros_at_task_start;

extern "C" void esp_yield()
{
    if (cont_can_yield(&g_cont))
    {
        cont_yield(&g_cont);
    }
}

extern "C" void esp_schedule()
{
    ets_post(LOOP_TASK_PRIORITY, 0, 0);
}

extern "C" void __yield()
{
    if (cont_can_yield(&g_cont))
    {
        esp_schedule();
        esp_yield();
    }
    else
    {
        panic();
    }
}

extern "C" void yield(void) __attribute__((weak, alias("__yield")));

extern "C" void optimistic_yield(uint32_t interval_us)
{
    if (cont_can_yield(&g_cont) &&
        (system_get_time() - g_micros_at_task_start) > interval_us)
    {
        yield();
    }
}

static void loop_wrapper()
{
    static bool setup_done = false;
    preloop_update_frequency();
    if (!setup_done)
    {
        setup();
#ifdef DEBUG_ESP_PORT
        DEBUG_ESP_PORT.setDebugOutput(true);
#endif
        setup_done = true;
    }
    loop();
    run_scheduled_functions();
    esp_schedule();
}

static void loop_task(os_event_t *events)
{
    g_micros_at_task_start = system_get_time();
    cont_run(&g_cont, &loop_wrapper);
    if (cont_check(&g_cont) != 0)
    {
        panic();
    }
}

static void do_global_ctors(void)
{
    void (**p)(void) = &__init_array_end;
    while (p != &__init_array_start)
    {
        (*--p)();
    }
}

extern "C" void __gdb_init() {}
extern "C" void gdb_init(void) __attribute__((weak, alias("__gdb_init")));

extern "C" void __gdb_do_break() {}
extern "C" void gdb_do_break(void) __attribute__((weak, alias("__gdb_do_break")));

void init_done()
{
    system_set_os_print(1);
    gdb_init();
    do_global_ctors();
    printf("\n%08x\n", core_version);
    esp_schedule();
}


extern "C" void user_init(void)
{
    struct rst_info *rtc_info_ptr = system_get_rst_info();
    memcpy((void *) &resetInfo, (void *) rtc_info_ptr, sizeof(resetInfo));

    uart_div_modify(0, UART_CLK_FREQ / (115200));

    init();

    initVariant();

    cont_init(&g_cont);

    ets_task(loop_task,
             LOOP_TASK_PRIORITY, g_loop_queue,
             LOOP_QUEUE_SIZE);

    system_init_done_cb(&init_done);
}


#elif defined(SPARK) || defined(PARTICLE)
#warning MAIN_SECTION 3 = Particle / Spark
// ============================================================================= Particle / Spark specific


#elif defined(MBED)
#warning MAIN_SECTION 4 = mbed
// ============================================================================= mbed specific


#elif defined(MPIDE) || defined(CHIPKIT)
#warning MAIN_SECTION 5 = chipKIT
// ============================================================================= chipKIT specific


#elif defined(DIGISPARK)
#warning MAIN_SECTION 6 = Digispark
// ============================================================================= Digispark specific


#elif defined(MICRODUINO)
#warning MAIN_SECTION 7 = Microduino
// ============================================================================= Microduino specific


#elif defined(ENERGIA_MT)
// ============================================================================= Energia Multi-Tasking specific

#include "rtosTasks.h"


#if defined(__CC3200R1M1RGC__) || defined(__CC3200R1MXRGCR__) || defined(ENERGIA_ARCH_CC3200)
#warning MAIN_SECTION 7 = CC3200 EMT
// ----------------------------------------------------------------------------- LaunchPad CC3200 with RTOS specific

/*
    ======== main.cpp ========
    MT wiring Task framework
*/
#include <stddef.h>
//#include <oslib/osi.h>

/* XDC Header files */
#include <xdc/cfg/global.h>

/* BIOS Header files */
#include <ti/sysbios/BIOS.h>
#include <ti/sysbios/knl/Task.h>
#include <ti/sysbios/family/arm/m3/Hwi.h>
#include <xdc/runtime/System.h>

/* Board Support Header files (from configuration closure) */
//#include "Board.h"
#include <ti/runtime/wiring/Energia.h>

//#if defined(__TI_COMPILER_VERSION__) || defined(__GNUC__)
//__extern int __UNUSED_start__, __UNUSED_end__;
//#define START (&__UNUSED_start__)
//#define END   (&__UNUSED_end__)
//#else
//#define START NULL
//#define END   NULL
//#endif

/* magic insertion point 769d20fcd7a0eedaf64270f591438b01 */

/*
    __extern void setup();
    __extern void loop();

    #define NUM_SKETCHES 1

    void (*func_ptr[NUM_SKETCHES][2])(void) = {
	{setup, loop}
    };
*/

Void the_task(UArg _task_setup, UArg _task_loop);

/*  set priority of simple link callbacks
    must be >= 0 and < Task_numPriorities
    where Task_numPriorities is set by
    TI-RTOS config
*/
#define SIMPLELINK_PRI 3

/* Wiring-specific GPIO HW interrupt vectors */
//__extern void Wiring_GPIO_hwiIntFxn(UArg callbacks);

/*
    ======== main task ========
*/
Void the_task(UArg _task_setup, UArg _task_loop)
{
    /* Call setup once */
    (*(void(*)()) _task_setup)();

    /* Call loop repeatedly */
    for (;;)
    {
        (*(void(*)()) _task_loop)();
        System_flush();
        Task_yield();
    }
}

// ~
///
/// @page       Main setup
///
/// @author		Rei Vilo
/// @date		Jun 30, 2015 10:18
/// @version	102
///
/// @copyright	(c) Rei Vilo, 2015
/// @copyright	CC = BY SA NC
/// @{

///
/// @brief      main setup function
/// @note       rtosSetup() is called before all other tasks
/// *   Optional declaration
/// *   Defined in main sketch or in rtosGlobals
/// @warning    No delay() in rtosSetup()!
///
void rtosSetup() __attribute__((weak));

///
/// @brief	Proxy function for Task_create()
/// @note   Task_create() requires non-weak functions
///
void rtos_Setup()
{
    rtosSetup();
};
// ~


/*
    ======== main ========
*/
int main()
{
    /* initialize all device/board specific peripherals */
    Board_init();  /* this function is generated as part of TI-RTOS config */

    //	System_printf("unused memory: start = %p, end = %p\n", START, END);

    /*  The SimpleLink Host Driver requires a mechanism to allow functions to
        execute in task context.  The SpawnTask is created to handle such
        situations.  This task will remain blocked until the host driver
        posts a function.  If the SpawnTask priority is higher than other
        tasks, it will immediately execute that function and return to a
        blocked state.  Otherwise, it will remain ready until it has
        the highest priority of any ready function.
    */
    //	VStartSimpleLinkSpawnTask(SIMPLELINK_PRI);

    /*  hijack the common hwi func to point to Wiring's handler that clears
        the GPIO interrupt
    */
    //	Hwi_setFunc(Hwi_handle((Hwi_Struct *)Board_gpioCallbacks0.hwiStruct),
    //		Wiring_GPIO_hwiIntFxn, (UArg)&Board_gpioCallbacks0);
    //	Hwi_setFunc(Hwi_handle((Hwi_Struct *)Board_gpioCallbacks1.hwiStruct),
    //		Wiring_GPIO_hwiIntFxn, (UArg)&Board_gpioCallbacks1);
    //	Hwi_setFunc(Hwi_handle((Hwi_Struct *)Board_gpioCallbacks2.hwiStruct),
    //		Wiring_GPIO_hwiIntFxn, (UArg)&Board_gpioCallbacks2);
    //	Hwi_setFunc(Hwi_handle((Hwi_Struct *)Board_gpioCallbacks3.hwiStruct),
    //		Wiring_GPIO_hwiIntFxn, (UArg)&Board_gpioCallbacks3);

    Task_Params taskParams;

    System_printf("Startup\n");
    System_flush();

    /* initialize taskParams and set to default */
    Task_Params_init(&taskParams);

    /* All tasks have the same priority */
    taskParams.priority = Task_numPriorities - 1;
    taskParams.stackSize = 0xc00;

    // ~
    // Add rtosSetup() as first tasks
    taskParams.instance->name = (xdc_String) "rtosSetup";
    Task_create((Task_FuncPtr) rtos_Setup, &taskParams, NULL);
    // ~

    uint8_t i = 0;
    for (i = 0; i < NUM_SKETCHES; i++)
    {
        /* Set arg0 to setup() */
        taskParams.arg0 = (xdc_UArg)func_ptr[i][0];
        /* Set ar1 to loop */
        taskParams.arg1 = (xdc_UArg)func_ptr[i][1];
        /* Set the task name */
        taskParams.instance->name = (xdc_String) taskNames[i];
        /* Create the task */
        Task_create(the_task, &taskParams, NULL);
    }

    /* does not return */
    BIOS_start();

    return (0); /* should never get here, but just in case ... */
}


#elif defined(__MSP432P401R__) || defined(ENERGIA_ARCH_MSP432)
#warning MAIN_SECTION 8 = MSP432 EMT
// ----------------------------------------------------------------------------- LaunchPad MSP432 with RTOS specific

/*
    ======== main.cpp ========
    MT wiring Task framework
*/
#include <stddef.h>
//#include <oslib/osi.h>

/* XDC Header files */
#include <xdc/cfg/global.h>

/* BIOS Header files */
#include <ti/sysbios/BIOS.h>
#include <ti/sysbios/knl/Task.h>
#include <ti/sysbios/family/arm/m3/Hwi.h>
#include <xdc/runtime/System.h>

/* Board Support Header files (from configuration closure) */
#include <ti/runtime/wiring/Energia.h>

/* magic insertion point 769d20fcd7a0eedaf64270f591438b01 */
//extern void setupsketch_aug24a();
//extern void loopsketch_aug24a();
//
//#define NUM_SKETCHES 1
//void (*func_ptr[NUM_SKETCHES][2])(void) = {
//	{setupsketch_aug24a, loopsketch_aug24a}
//};
//const char *taskNames[] = {
//	"loopsketch_aug24a"
//};

Void the_task(UArg _task_setup, UArg _task_loop);

/*  set priority of simple link callbacks
    must be >= 0 and < Task_numPriorities
    where Task_numPriorities is set by
    TI-RTOS config
*/

// ~
///
/// @page       Main setup
///
/// @author		Rei Vilo
/// @date		Jun 30, 2015 10:18
/// @version	102
///
/// @copyright	(c) Rei Vilo, 2015
/// @copyright	CC = BY SA NC
/// @{

///
/// @brief      main setup function
/// @note       rtosSetup() is called before all other tasks
/// *   Optional declaration
/// *   Defined in main sketch or in rtosGlobals
/// @warning    No delay() in rtosSetup()!
///
void rtosSetup() __attribute__((weak));

///
/// @brief	Proxy function for Task_create()
/// @note   Task_create() requires non-weak functions
///
void rtos_Setup()
{
    rtosSetup();
};
// ~

/////
///// @brief	Proxy function for Task_create()
///// @note   Task_create() requires non-weak functions
/////
//void rtos_Loop() { ; }

/// @}

/*
    ======== main task ========
*/
Void the_task(UArg _task_setup, UArg _task_loop)
{
    /* Call setup once */
    (*(void(*)()) _task_setup)();

    /* Call loop repeatedly */
    for (;;)
    {
        (*(void(*)()) _task_loop)();
        System_flush();
        Task_yield();
    }
}
/*
    ======== main ========
*/
int main()
{
    /* initialize all device/board specific peripherals */
    Board_init();  /* this function is generated as part of TI-RTOS config */

    /*  The SimpleLink Host Driver requires a mechanism to allow functions to
        execute in task context.  The SpawnTask is created to handle such
        situations.  This task will remain blocked until the host driver
        posts a function.  If the SpawnTask priority is higher than other
        tasks, it will immediately execute that function and return to a
        blocked state.  Otherwise, it will remain ready until it has
        the highest priority of any ready function.
    */

    Task_Params taskParams;

    /* initialize taskParams and set to default */
    Task_Params_init(&taskParams);

    /* All tasks have the same priority */
    taskParams.priority = Task_numPriorities - 2;
    taskParams.stackSize = 0x800;

    // ~
    // Add rtosSetup() as first tasks
    taskParams.instance->name = (xdc_String) "rtosSetup";
    Task_create((Task_FuncPtr) rtos_Setup, &taskParams, NULL);
    // ~

    uint8_t i = 0;
    for (i = 0; i < NUM_SKETCHES; i++)
    {
        /* Set arg0 to setup() */
        taskParams.arg0 = (xdc_UArg)func_ptr[i][0];
        /* Set ar1 to loop */
        taskParams.arg1 = (xdc_UArg)func_ptr[i][1];
        /* Set the task name */
        taskParams.instance->name = (xdc_String) taskNames[i];
        /* Create the task */
        Task_create(the_task, &taskParams, NULL);
    }

    /* does not return */
    BIOS_start();

    return (0); /* should never get here, but just in case ... */
}

#elif defined(__CC2650__)
#warning MAIN_SECTION 9 = CC2650 EMT
// ----------------------------------------------------------------------------- SensorTag CC2650 with RTOS specific

/*
    ======== main.cpp ========
    MT wiring Task framework
*/
#include <stddef.h>
//#include <oslib/osi.h>

/* XDC Header files */
#include <xdc/cfg/global.h>

/* BIOS Header files */
#include <ti/sysbios/BIOS.h>
#include <ti/sysbios/knl/Task.h>
#include <ti/sysbios/family/arm/m3/Hwi.h>
#include <xdc/runtime/System.h>
/* Board Support Header files (from configuration closure) */
//#include "Board.h"
#include <ti/runtime/wiring/Energia.h>

//#if defined(__TI_COMPILER_VERSION__) || defined(__GNUC__)
//__extern int __UNUSED_start__, __UNUSED_end__;
//#define START (&__UNUSED_start__)
//#define END   (&__UNUSED_end__)
//#else
//#define START NULL
//#define END   NULL
//#endif

/* magic insertion point 769d20fcd7a0eedaf64270f591438b01 */



/*
    __extern void setup();
    __extern void loop();

    #define NUM_SKETCHES 1

    void (*func_ptr[NUM_SKETCHES][2])(void) = {
	{setup, loop}
    };
*/

xdc_Void the_task(xdc_UArg _task_setup, xdc_UArg _task_loop);

/*  set priority of simple link callbacks
    must be >= 0 and < Task_numPriorities
    where Task_numPriorities is set by
    TI-RTOS config
*/
//#define SIMPLELINK_PRI 3

/* Wiring-specific GPIO HW interrupt vectors */
__extern void Wiring_GPIO_hwiIntFxn(xdc_UArg callbacks);

// ~
///
/// @page       Main setup
///
/// @author		Rei Vilo
/// @date		Jun 30, 2015 10:18
/// @version	102
///
/// @copyright	(c) Rei Vilo, 2015
/// @copyright	CC = BY SA NC
/// @{

///
/// @brief      main setup function
/// @note       rtosSetup() is called before all other tasks
/// *   Optional declaration
/// *   Defined in main sketch or in rtosGlobals
/// @warning    No delay() in rtosSetup()!
///
void rtosSetup() __attribute__((weak));

///
/// @brief	Proxy function for Task_create()
/// @note   Task_create() requires non-weak functions
///
void rtos_Setup()
{
    rtosSetup();
};
// ~


/*
    ======== main task ========
*/
xdc_Void the_task(xdc_UArg _task_setup, xdc_UArg _task_loop)
{
    /* Call setup once */
    (*(void(*)()) _task_setup)();

    /* Call loop repeatedly */
    for (;;)
    {
        (*(void(*)()) _task_loop)();
        System_flush();
        Task_yield();
    }
}
/*
    ======== main ========
*/
int main()
{
    /* initialize all device/board specific peripherals */
    Board_init();  /* this function is generated as part of TI-RTOS config */

    /*  The SimpleLink Host Driver requires a mechanism to allow functions to
        execute in task context.  The SpawnTask is created to handle such
        situations.  This task will remain blocked until the host driver
        posts a function.  If the SpawnTask priority is higher than other
        tasks, it will immediately execute that function and return to a
        blocked state.  Otherwise, it will remain ready until it has
        the highest priority of any ready function.
    */
    //	VStartSimpleLinkSpawnTask(SIMPLELINK_PRI);

    /*  hijack the common hwi func to point to Wiring's handler that clears
        the GPIO interrupt
    */

    //	Hwi_setFunc(Hwi_handle((Hwi_Struct *)Board_gpioCallbacks0.hwiStruct),
    //		Wiring_GPIO_hwiIntFxn, (UArg)&Board_gpioCallbacks0);
    //	Hwi_setFunc(Hwi_handle((Hwi_Struct *)Board_gpioCallbacks1.hwiStruct),
    //		Wiring_GPIO_hwiIntFxn, (UArg)&Board_gpioCallbacks1);
    //	Hwi_setFunc(Hwi_handle((Hwi_Struct *)Board_gpioCallbacks2.hwiStruct),
    //		Wiring_GPIO_hwiIntFxn, (UArg)&Board_gpioCallbacks2);
    //	Hwi_setFunc(Hwi_handle((Hwi_Struct *)Board_gpioCallbacks3.hwiStruct),
    //		Wiring_GPIO_hwiIntFxn, (UArg)&Board_gpioCallbacks3);

    Task_Params taskParams;

    /* initialize taskParams and set to default */
    Task_Params_init(&taskParams);

    /* All tasks have the same priority */
    taskParams.priority = Task_numPriorities - 2;
    taskParams.stackSize = 0x800;

    // ~
    // Add rtosSetup() as first tasks
    taskParams.instance->name = (xdc_String) "rtosSetup";
    Task_create((Task_FuncPtr) rtos_Setup, &taskParams, NULL);
    // ~

    uint8_t i = 0;
    for (i = 0; i < NUM_SKETCHES; i++)
    {
        /* Set arg0 to setup() */
        taskParams.arg0 = (xdc_UArg)func_ptr[i][0];
        /* Set ar1 to loop */
        taskParams.arg1 = (xdc_UArg)func_ptr[i][1];
        /* Set the task name */
        taskParams.instance->name = (xdc_String) taskNames[i];
        /* Create the task */
        Task_create(the_task, &taskParams, NULL);
    }

    /* does not return */
    BIOS_start();

    return (0); /* should never get here, but just in case ... */
}


#elif defined(__CC1310__) || defined(ENERGIA_ARCH_CC13XX)
#warning MAIN_SECTION 41 = CC1310 EMT
// ----------------------------------------------------------------------------- LaunchPad CC1310 specific


#else

#error Board for Energia MT not defined

#endif

#elif defined(ENERGIA)
// ============================================================================= Energia Standard

#if defined(__CC3200R1M1RGC__) || defined(__CC3200R1MXRGCR__) || defined(ENERGIA_ARCH_CC3200)
#warning MAIN_SECTION 10 = CC3200 standard
// ----------------------------------------------------------------------------- LaunchPad CC3200 specific

#include <Energia.h>
#include "inc/hw_gpio.h"
#include "driverlib/rom_map.h"
#include "driverlib/prcm.h"
#include "driverlib/interrupt.h"
#include "driverlib/systick.h"
#include <driverlib/utils.h>
#include "inc/hw_hib1p2.h"
#include "inc/hw_hib3p3.h"

extern void (* const g_pfnVectors[])(void);

#ifdef __cplusplus
extern "C" {
#endif

void _init(void)
{
    IntVTableBaseSet((unsigned long)&g_pfnVectors[0]);

    MAP_PRCMPeripheralClkEnable(PRCM_GPIOA0, PRCM_RUN_MODE_CLK);
    MAP_PRCMPeripheralClkEnable(PRCM_GPIOA1, PRCM_RUN_MODE_CLK);
    MAP_PRCMPeripheralClkEnable(PRCM_GPIOA2, PRCM_RUN_MODE_CLK);
    MAP_PRCMPeripheralClkEnable(PRCM_GPIOA3, PRCM_RUN_MODE_CLK);

    MAP_IntMasterEnable();
    PRCMCC3200MCUInit();
    MAP_SysTickIntEnable();
    MAP_SysTickPeriodSet(F_CPU / 1000);
    MAP_SysTickEnable();
}

#ifdef __cplusplus
} /* extern "C" */
#endif

int main(void)
{
    setup();

    for (;;)
    {
        loop();
        if (serialEventRun)
        {
            serialEventRun();
        }
    }
}


#elif defined(__TMS320F28027__) || defined(__TMS320F28069__)
#warning MAIN_SECTION 11 = C2000 standard
// ----------------------------------------------------------------------------- C2000 specific


#elif defined(__LM4F120H5QR__) || defined(__TM4C1230C3PM__) || defined(__TM4C129XNCZAD__) || defined(__TM4C123GH6PM__) || defined(ENERGIA_ARCH_TIVAC)
#warning MAIN_SECTION 12 = LM4F standard
// ----------------------------------------------------------------------------- LaunchPad Stellaris and Tiva specific

#include <Energia.h>

#if defined(PART_TM4C129XNCZAD)
#include "inc/tm4c129xnczad.h"
#elif defined(PART_TM4C1294NCPDT)
#include "inc/tm4c1294ncpdt.h"
#elif defined(PART_TM4C1233H6PM) || defined(PART_LM4F120H5QR)
#include "inc/tm4c123gh6pm.h"
#else
#error "**** No PART defined or unsupported PART ****"
#endif

#include "inc/hw_gpio.h"
#include "driverlib/rom.h"
#include "driverlib/sysctl.h"
#include "driverlib/eeprom.h"

#ifdef __cplusplus
extern "C" {

void _init(void)
{
    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_EEPROM0);
    if (ROM_EEPROMInit() == EEPROM_INIT_ERROR)
    {
        if (ROM_EEPROMInit() != EEPROM_INIT_ERROR)
        {
            EEPROMMassErase();
        }
    }

    timerInit();

    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOA);
    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOB);
    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOC);
    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOD);
    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOE);
    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOF);
    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOG);
    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOH);
    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOJ);
    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOK);
    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOL);
    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOM);
    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPION);
    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOP);
    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOQ);
#ifdef TARGET_IS_SNOWFLAKE_RA0
    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOR);
    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOS);
    ROM_SysCtlPeripheralEnable(SYSCTL_PERIPH_GPIOT);
#endif

    //Unlock and commit NMI pins PD7 and PF0
    HWREG(GPIO_PORTF_BASE + GPIO_O_LOCK) = 0x4C4F434B;
    HWREG(GPIO_PORTF_BASE + GPIO_O_CR) |= 0x1;
    HWREG(GPIO_PORTD_BASE + GPIO_O_LOCK) = 0x4C4F434B;
    HWREG(GPIO_PORTD_BASE + GPIO_O_CR) |= 0x80;
} /* void _init(void) */

} /* extern "C" */
#endif

int main(void)
{
    setup();

    for (;;)
    {
        loop();
        if (serialEventRun)
        {
            serialEventRun();
        }
    }
}


#else
// ----------------------------------------------------------------------------- LaunchPad MSP430 and Experimeter Board FR5739 specific

#include <Energia.h>

int main(void)
{
    init();

    setup();

    for (;;)
    {
        loop();
        if (serialEventRun)
        {
            serialEventRun();
        }
    }

    return 0;
}

#endif                                                                          // Energia


#elif defined(LIGHTBLUE_CORE)
#warning MAIN_SECTION 13 = LightBlue Bean
// ============================================================================= LightBlue Bean specific

#elif defined(ROBOTIS)
#warning MAIN_SECTION 14 = Robotis
// ============================================================================= Robotis specific

#elif defined(MAPLE_IDE)
#warning MAIN_SECTION 15 = Maple
// ============================================================================= Maple specific

#include <WProgram.h>

// *****************************************************************************
//  The MIT Licence
//
//  Copyright (c) 2010 LeafLabs LLC.
//
//  Permission is hereby granted, free of charge, to any person
//  obtaining a copy of this software and associated documentation
//  files (the "Software"), to deal in the Software without
//  restriction, including without limitation the rights to use, copy,
//  modify, merge, publish, distribute, subLicence, and/or sell copies
//  of the Software, and to permit persons to whom the Software is
//  furnished to do so, subject to the following conditions:
//
//  The above copyright notice and this permission notice shall be
//  included in all copies or substantial portions of the Software.
//
//  THE SOFTWARE IS PROVIDED "AS IS", WITHOUT WARRANTY OF ANY KIND,
//  EXPRESS OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF
//  MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND
//  NONINFRINGEMENT. IN NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS
//  BE LIABLE FOR ANY CLAIM, DAMAGES OR OTHER LIABILITY, WHETHER IN AN
//  ACTION OF CONTRACT, TORT OR OTHERWISE, ARISING FROM, OUT OF OR IN
//  CONNECTION WITH THE SOFTWARE OR THE USE OR OTHER DEALINGS IN THE
//  SOFTWARE.
// ****************************************************************************

__attribute__((constructor)) void premain()
{
    init();
}

int main(void)
{
    setup();

    for (;;)
    {
        loop();
    }

    return 0;
}


#elif defined(TEENSYDUINO) || defined(CORE_TEENSY)
// ============================================================================= Teensy specific

#if defined(__MK20DX128__) || defined(__MK20DX256__) || defined(__MK64FX512__) || defined(__MK66FX1M0__) || defined(__MKL26Z64__)
#warning MAIN_SECTION 16 = Teensy 3
// ----------------------------------------------------------------------------- Teensy 3 specific

#include "WProgram.h"

extern "C" int main(void)
{
    // Arduino's main() function just calls setup() and loop()....
    setup();
    while (1)
    {
        loop();
        yield();
    }
}

#else
#warning MAIN_SECTION 17 = Teensy 2
// ----------------------------------------------------------------------------- Teensy 2 specific

#include "WProgram.h"

//int main(void) __attribute__((noreturn));
int main(void)
{
    _init_Teensyduino_internal_();

    setup();

    for (;;)
    {
        loop();
    }
}

#endif                                                                          // Teensy


#elif defined(PANSTAMP_AVR) || defined(PANSTAMP_NRG) || defined(ARDUINO_PANSTAMP_AVR)
#warning MAIN_SECTION 18 = panStamp
// ============================================================================= panStamp specific


#elif defined(WIRING)
#warning MAIN_SECTION 19 = Wiring
// ============================================================================= Wiring specific


#elif defined(RFDUINO)
#warning MAIN_SECTION 20 = RFduino
// ============================================================================= RFduino specific


#elif defined(COSA)
#warning MAIN_SECTION 21 = Cosa
// ============================================================================= Cosa for AVR specific

#elif defined(REDBEARLAB)
#warning MAIN_SECTION 22 = RedBearLab
// ============================================================================= RedBearLab specific


#elif defined(ARDUINO)
// ============================================================================= Arduino specific

#if (ARDUINO < 10800)
// ----------------------------------------------------------------------------- Arduino < 1.8.x specific
#error Arduino 1.8.0 required


#else
// ----------------------------------------------------------------------------- Arduino 1.8.x specific


#if defined(__ARDUINO_X86__)
#warning MAIN_SECTION 28 = Arduino 1.8.x X86
// ............................................................................. Arduino 1.8.x X86 architecture specific

/*
 main.cpp userspace main loop for Intel Galileo family boards
 Copyright (C) 2014 Intel Corporation
 
 This library is free software; you can redistribute it and/or
 modify it under the terms of the GNU Lesser General Public
 License as published by the Free Software Foundation; either
 version 2.1 of the License, or (at your option) any later version.
 
 This library is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 Lesser General Public License for more details.
 
 You should have received a copy of the GNU Lesser General Public
 License along with this library; if not, write to the Free Software
 Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 
 */
// Arduino hooks
#include <Arduino.h>
#include <trace.h>
#include <interrupt.h>
#include <sys/stat.h>

#define PLATFORM_NAME_PATH "/sys/devices/platform/"

/************************ Static *************************/
#define MY_TRACE_PREFIX __FILE__

/************************ Global *************************/
int main(int argc, char * argv[])
{
    char *platform_path = NULL;
    struct stat s;
    int err;
    
    // Install a signal handler
    
    // make ttyprintk at some point
    stdout = freopen("/tmp/log.txt", "w", stdout);
    if (stdout == NULL)
    {
        fprintf(stderr, "unable to remap stdout !\n");
        exit(-1);
    }
    fflush(stdout);
    
    stderr = freopen("/tmp/log_er.txt", "w", stderr);
    if (stderr == NULL)
    {
        printf("Unable to remap stderr !\n");
        exit(-1);
    }
    fflush(stderr);
    
    // Snapshot time counter
    if (timeInit() < 0)
    {
        exit(-1);
    }
    
    // debug for the user
    if (argc < 2)
    {
        fprintf(stderr, "./sketch tty0\n");
        return -1;
    }
    printf("started with binary=%s Serial=%s\n", argv[0], argv[1]);
    fflush(stdout);
    
    // check if we're running on the correct platform
    // and refuse to run if no match
    
#if GALILEO_IDE
    platform_path = (char *)malloc(sizeof(PLATFORM_NAME_PATH) + sizeof(PLATFORM_NAME));
    sprintf(platform_path, "%s%s", PLATFORM_NAME_PATH, PLATFORM_NAME);
    
    printf("checking platform_path [%s]\n", platform_path);
    fflush(stdout);
    
    err = stat(platform_path, &s);
    
    if (err != 0)
    {
        fprintf(stderr, "stat failed checking for %s with error code %d\n", PLATFORM_NAME, err);
        free(platform_path);
        return -1;
    }
    if (!S_ISDIR(s.st_mode))
    {
        /* exists but is no dir */
        fprintf(stderr, "Target board not a %s\n", PLATFORM_NAME);
        free(platform_path);
        return -1;
    }
    
    printf("Running on a %s platform (%s)\n", PLATFORM_NAME, platform_path);
    fflush(stdout);
    
    free(platform_path);
#endif
    
    // TODO: derive trace level and optional IP from command line
    trace_init(VARIANT_TRACE_LEVEL, 0);
    trace_target_enable(TRACE_TARGET_UART);
    
    // Call Arduino init
    init(argc, argv);
    
    // Init IRQ layer
    // Called after init() to ensure I/O permissions inherited by pthread
    interrupt_init();
    
#if defined(USBCON)
    USBDevice.attach();
#endif
    
    setup();
    for (;;)
    {
        loop();
        //if (serialEventRun) serialEventRun();
    }
    return 0;
}

#elif defined(CURIE_IDE) || defined(__ARDUINO_ARC__) || defined(ARDUINO_ARCH_ARC32)
#warning MAIN_SECTION 40 = Arduino 1.8.x ARC32
// ............................................................................. Arduino 1.8.x Curie architecture specific

/*
 main.cpp userspace main loop for Arduino 101 family boards
 Copyright (C) 2014 Intel Corporation
 
 This library is free software; you can redistribute it and/or
 modify it under the terms of the GNU Lesser General Public
 License as published by the Free Software Foundation; either
 version 2.1 of the License, or (at your option) any later version.
 
 This library is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 Lesser General Public License for more details.
 
 You should have received a copy of the GNU Lesser General Public
 License along with this library; if not, write to the Free Software
 Foundation, Inc., 51 Franklin Street, Fifth Floor, Boston, MA  02110-1301  USA
 
 */
// Arduino hooks
#include "Arduino.h"

// Weak empty variant initialization function.
// May be redefined by variant files.
void initVariant() __attribute__((weak));
void initVariant() { }

/*
 \brief Main entry point of Arduino application
 */
int main(void)
{
    //init();
    
    initVariant();
    
    // delay(1);
    
#if defined(USBCON)
    USBDevice.attach();
#endif
    
    setup();
    
    for (;;) /* This infinite loop is intentional and requested by design */
    {
        loop();
        if (serialEventRun)
        {
            serialEventRun();
        }
    }
    
    return 0;
}


#elif defined(__SAM3X8E__) || defined(ARDUINO_ARCH_SAM)
#warning MAIN_SECTION 29 = Arduino 1.8.x SAM
// ............................................................................. Arduino 1.8.x SAM architecture specific

/*
 main.cpp - Main loop for Arduino sketches
 Copyright (c) 2005-2013 Arduino Team.  All right reserved.
 
 This library is free software; you can redistribute it and/or
 modify it under the terms of the GNU Lesser General Public
 License as published by the Free Software Foundation; either
 version 2.1 of the License, or (at your option) any later version.
 
 This library is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 Lesser General Public License for more details.
 
 You should have received a copy of the GNU Lesser General Public
 License along with this library; if not, write to the Free Software
 Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */

#define ARDUINO_MAIN
#include "Arduino.h"

/*
 Cortex-M3 Systick IT handler
 */
/*
 extern void SysTick_Handler( void )
 {
 // Increment tick count each ms
 TimeTick_Increment() ;
 }
 */

// Weak empty variant initialization function.
// May be redefined by variant files.
void initVariant() __attribute__((weak));
void initVariant() { }

/*
 \brief Main entry point of Arduino application
 */
int main(void)
{
    // Initialize watchdog
    watchdogSetup();
    
    init();
    
    initVariant();
    
    delay(1);
    
#if defined(USBCON)
    USBDevice.attach();
#endif
    
    setup();
    
    for (;;)
    {
        loop();
        if (serialEventRun)
        {
            serialEventRun();
        }
    }
    
    return 0;
}


#elif defined(__SAMD21G18A__) || defined(ARDUINO_ARCH_SAMD)
#warning MAIN_SECTION 30 = Arduino 1.8.x SAMD
// ............................................................................. Arduino 1.8.x SAMD architecture specific

/*
 Copyright (c) 2015 Arduino LLC.  All right reserved.
 
 This library is free software; you can redistribute it and/or
 modify it under the terms of the GNU Lesser General Public
 License as published by the Free Software Foundation; either
 version 2.1 of the License, or (at your option) any later version.
 
 This library is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.
 See the GNU Lesser General Public License for more details.
 
 You should have received a copy of the GNU Lesser General Public
 License along with this library; if not, write to the Free Software
 Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */

#define ARDUINO_MAIN
#include "Arduino.h"

// Weak empty variant initialization function.
// May be redefined by variant files.
void initVariant() __attribute__((weak));
void initVariant() { }

// Initialize C library
extern "C" void __libc_init_array(void);

/*
 \brief Main entry point of Arduino application
 */
int main(void)
{
    init();
    
    __libc_init_array();
    
    initVariant();
    
    delay(1);
#if defined(USBCON)
    USBDevice.init();
    USBDevice.attach();
#endif
    
    setup();
    
    for (;;)
    {
        loop();
        if (serialEventRun)
        {
            serialEventRun();
        }
    }
    
    return 0;
}

#else
#warning MAIN_SECTION 31 = Arduino 1.8.x AVR
// ............................................................................. Arduino 1.8.x AVR architecture specific

/*
 main.cpp - Main loop for Arduino sketches
 Copyright (c) 2005-2013 Arduino Team.  All right reserved.
 
 This library is free software; you can redistribute it and/or
 modify it under the terms of the GNU Lesser General Public
 License as published by the Free Software Foundation; either
 version 2.1 of the License, or (at your option) any later version.
 
 This library is distributed in the hope that it will be useful,
 but WITHOUT ANY WARRANTY; without even the implied warranty of
 MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the GNU
 Lesser General Public License for more details.
 
 You should have received a copy of the GNU Lesser General Public
 License along with this library; if not, write to the Free Software
 Foundation, Inc., 51 Franklin St, Fifth Floor, Boston, MA  02110-1301  USA
 */

#include <Arduino.h>

// Declared weak in Arduino.h to allow user redefinitions.
int atexit(void (* /*func*/)())
{
    return 0;
}

// Weak empty variant initialization function.
// May be redefined by variant files.
void initVariant() __attribute__((weak));
void initVariant() { }

void setupUSB() __attribute__((weak));
void setupUSB() { }

int main(void)
{
    init();
    
    initVariant();
    
#if defined(USBCON)
    USBDevice.attach();
#endif
    
    setup();
    
    for (;;)
    {
        loop();
        if (serialEventRun)
        {
            serialEventRun();
        }
    }
    
    return 0;
}

#endif                                                                          // end architecture Arduino 1.8.x

#endif                                                                          // end Arduino

#else                                                                           // error
#error Platform not defined
#endif                                                                          // end IDE

// Sketch
#include "SPEEEduino_LowLevel.ino"


#endif                                                                          // end embedXcode

